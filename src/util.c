#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <unistd.h>
#include <errno.h>
#include <sys/wait.h>
#include <fcntl.h>
#include "../include/util.h"

#define MAX_PROCESS_AMOUNT 5
#define MAX_PARAMS_AMOUNT 2

void signal_prevent()
{
    struct sigaction act;

    // Sets the handler for the SIGINT signal
    if (sigaction(SIGINT, NULL, &act) == -1)
    {
        perror(RED "Failed to get old handler for SIGINT" RESET);
    }

    else if (act.sa_handler != SIG_IGN)
    {
        // If the treatment for this signal is not ignore, set ignore as the adopted behavior
        // Therefore, processes generated by the shell will not be able to receive SIGINT signals
        act.sa_handler = SIG_IGN;
        if (sigaction(SIGINT, &act, NULL) == -1)
        {
            perror(RED "Failed to ignore SIGINT" RESET);
        }

        // The same is made for SIGQUIT
        if (sigaction(SIGQUIT, &act, NULL) == -1)
        {
            perror(RED "Failed to ignore SIGQUIT" RESET);
        }

        // And for SIGTSTP
        if (sigaction(SIGTSTP, &act, NULL) == -1)
        {
            perror(RED "Failed to ignore SIGQUIT" RESET);
        }
    }
}

void shell_print_name(char first)
{
    // If shell execution is first, terminal is cleared
    if (first == 'y')
    {
        system("clear");
    }

    // Print buffer info
    printf(GREEN "fsh" PURPLE "> " RESET);
}

void free_commands(char ***commands)
{
    for (int i = 0; i < MAX_PROCESS_AMOUNT; i++)
    {
        for (int j = 0; j < MAX_PARAMS_AMOUNT + 1; j++)
        {
            if (commands[i][j] != NULL)
            {
                // Visits each parameter of a command and frees it
                free(commands[i][j]);
            }
        }
        // Freeing the command
        free(commands[i]);
    }

    // Freeing the vector of commands
    free(commands);
}

static void exec_process_aux(char **background_process)
{
    // Create the process to be executed
    pid_t child = fork();

    // Verify if the fork was successful
    if (child < 0)
    {
        printf(RED "Error on background process creation!\n" RESET);
    }

    else if (child == 0)
    {
        // Definition of the path to executable that will be executed by the new process
        char path[2000];

        sprintf(path, "/bin/%s", background_process[0]);

        // Create a new process due to consciouness problem
        __pid_t consciouness = fork();

        // Redirecting stdin and stdout to null file. It is made to avoid background processes writing
        int devnull = open("/dev/null", O_RDWR);
        int original_stdout = dup(STDOUT_FILENO);
        dup2(devnull, STDIN_FILENO);
        dup2(devnull, STDOUT_FILENO);

        // Execution of the executable (command)
        execv(path, background_process);

        // Print error message if execution goes wrong
        dup2(original_stdout, STDOUT_FILENO);
        printf(RED "Error on background execution!\n");
    }
}

char ***shell_read_commands(char first, int *commands_amount)
{
    char line[2000];

    // Allocating memory to commands vector
    char ***commands = (char ***)calloc(MAX_PROCESS_AMOUNT, sizeof(char **));

    // Allocating memory for each command and initializing it
    for (int i = 0; i < MAX_PROCESS_AMOUNT; i++)
    {
        commands[i] = (char **)calloc((MAX_PARAMS_AMOUNT + 1), sizeof(char *));

        for (int j = 0; j < MAX_PARAMS_AMOUNT + 1; j++)
        {
            commands[i][j] = NULL;
        }
    }

    // If it is the first shell execution, a line will be read without cleaning the buffer
    if (first == 'y')
    {
        scanf("%[^\n]", line);
    }

    // Otherwise, the buffer is cleaned before line's reading
    else
    {
        scanf("%*c%[^\n]", line);
    }

    // Spliting the commands with # delimiter
    char *commands_aux[MAX_PROCESS_AMOUNT];
    char *command = strtok(line, "#");
    int count_proc = 0;

    while (command != NULL)
    {

        // If the user writes more than MAX_PROCESS_AMOUNT, a warning is shown and the shell aborts
        if (count_proc >= MAX_PROCESS_AMOUNT)
        {
            printf(RED "Error: You can't type more than five commands at once!\n" RESET);
            perror(RED "Aborting: more than five commands called!\n" RESET);
            abort();
        }

        // Removes extra spaces at the beginning of the command
        while (*command == ' ')
            command++;

        commands_aux[count_proc] = strdup(command);

        // Move to the next command separated by '#'
        command = strtok(NULL, "#");
        count_proc++;
    }

    for (int i = 0; i < count_proc; i++)
    {
        // Now we separate the parameters with ' '
        char *dup = strdup(commands_aux[i]);
        char *parameter = strtok(dup, " ");
        free(commands_aux[i]);

        // The first parameter is the main command, we store it in the first position
        if (parameter != NULL)
        {
            commands[i][0] = strdup(parameter);
        }

        int count_param = 1;

        // We retrieve the parameters using ' '
        parameter = strtok(NULL, " ");

        while (parameter != NULL)
        {
            // If more than MAX_PARAMS_AMOUNT is written by user, a warning is shown to say that the surplus parameter will be desconsidered
            if (count_param > MAX_PARAMS_AMOUNT)
                printf(RED "Error: You can't type more than two parameters for each command!\nParameter " PURPLE "%s " RED "from command " PURPLE "%s " RED "will be desconsidered!\n" RESET, parameter, commands[i][0]);

            else
            {
                // The parameter is saved in the commands vector
                commands[i][count_param] = strdup(parameter);
            }

            // Getting next parameter
            parameter = strtok(NULL, " ");
            count_param++;
        }

        // Freeing memory of auxiliary dup
        free(dup);
    }

    // The commands amount found is written in a value coming from main
    *commands_amount = count_proc;

    return commands;
}

void die(pid_t *background_processes, int *background_processes_amount)
{
    // If the command written is die, a SIGKILL is sent to all processes that are still alive
    // Therefore, the shell will finish all processes before finish itself
    for (int i = 0; i < *background_processes_amount; i++)
    {
        killpg(background_processes[i], SIGKILL);
    }

    // Showing a message
    printf(GREEN "Ok, cleaning all processes..." PURPLE "\nDone, exiting... Bye!\n" RESET);

    return;
}

void waitall(pid_t *background_processes, int *background_processes_amount)
{
    // If the command written is waitall, the shell will collect and free all zombie processes
    for (int i = 0; i < *background_processes_amount; i++)
    {
        pid_t group_id = background_processes[i];

        if (group_id != 0)
        {
            // For each processes registered in background, the shell collect its information. WNOHANG is used to keep shell unblocked while the process is running
            pid_t pid = waitpid(background_processes[i], NULL, WNOHANG);
        }
    }

    return;
}

int verify_if_top(char ***commands, int commands_amount)
{
    // Verifiy if htop or top commands were written among other commands.
    // If it is true, returns 1; Otherwise returns 0
    // These commands can't be executed in background, because a background process writing generates a SIGTTY
    // Furthermore, shell also handles the foreground process group. Therefore, if htop and top are written with other commands, they can't run
    if (commands_amount > 1)
    {
        int flag = 0;

        for (int i = 0; i < commands_amount; i++)
        {
            if (!strcmp(commands[i][0], "htop") || !strcmp(commands[i][0], "top"))
            {
                flag = 1;
            }
        }

        return flag;
    }

    return 0;
}

int verify_if_die_or_waitall(char ***commands, int commands_amount)
{
    // Verifiy if die or waitall were written among other commands
    // If it is true, return 1; Otherwise, returns 0
    // These commands must be written alone in line, due to work specification
    if (commands_amount > 1)
    {
        int flag = 0;

        for (int i = 0; i < commands_amount; i++)
        {
            if (!strcmp(commands[i][0], "die") || !strcmp(commands[i][0], "waitall"))
            {
                flag = 1;
            }
        }

        return flag;
    }

    return 0;
}

int execute_processes(char ***commands, int commands_amount, __pid_t *background_processes, int *background_processes_amount, int exit)
{
    // First, verify if htop or top were written with other commands in same line.
    // If it is true, return immediately
    if (verify_if_top(commands, commands_amount))
    {
        printf(PURPLE "HTOP " RED "or" PURPLE " TOP " RED "must be called exclusively alone in the command line!\nThis line will be desconsidered!\n" RESET);
        return exit;
    }

    // The same is executed to die or waitall commands
    if (verify_if_die_or_waitall(commands, commands_amount))
    {
        printf(PURPLE "DIE " RED "or" PURPLE " WAITALL " RED "must be called exclusively alone in the command line!\nThis line will be desconsidered!\n" RESET);
        return exit;
    }

    // If the command written is die, kill all child processes and finish shell
    if (!strcmp("die", commands[0][0]))
    {
        die(background_processes, background_processes_amount);

        exit = 0;
        return exit;
    }

    // If the command writeen is waitall, shell collects and frees all zombies
    else if (!strcmp("waitall", commands[0][0]))
    {
        waitall(background_processes, background_processes_amount);
        return exit;
    }

    else
    {
        // Otherwise, if just one command was written, it is executed in foreground
        // 0 is given as group id because this foreground process will be registered as a active group
        if (commands_amount == 1)
        {
            execute_process_foreground(commands[0], 0, background_processes, background_processes_amount);
        }

        // If more than one command is written, first execute the background process, get the group id and use it to set foreground process group
        // The reason to do it in this way is to kill all processes written in the same line if one of them receives a signal
        else
        {
            pid_t pid_group = execute_process_background(commands, commands_amount, background_processes, background_processes_amount);
            execute_process_foreground(commands[0], pid_group, background_processes, background_processes_amount);
        }
    }

    return exit;
}

pid_t execute_process_background(char ***background_process, int commands_amount, __pid_t *background_process_ids, int *background_processes_amount)
{
    // Forks a group leader. This child will set its group and than will generate all other background processes
    pid_t group_leader = fork();

    // Verify if fork was successful
    if (group_leader < 0)
    {
        printf(RED "Error: creation of processes in background!\n" RESET);
        exit(1);
    }

    // Code for group leader
    else if (group_leader == 0)
    {
        // Prevent the processes generated by group leader from some signals
        signal_prevent();

        // Change the group id of the group leader to its PID
        setpgid(0, getpid());

        // Verify how many commands were written and create all
        if (commands_amount == 2)
        {
            exec_process_aux(background_process[1]);
        }

        else if (commands_amount == 3)
        {
            exec_process_aux(background_process[1]);
            exec_process_aux(background_process[2]);
        }

        else if (commands_amount == 4)
        {
            exec_process_aux(background_process[1]);
            exec_process_aux(background_process[2]);
            exec_process_aux(background_process[3]);
        }

        else if (commands_amount == 5)
        {
            exec_process_aux(background_process[1]);
            exec_process_aux(background_process[2]);
            exec_process_aux(background_process[3]);
            exec_process_aux(background_process[4]);
        }

        // Stay blocked while background processes generated in the same command line haven't finished yet
        pid_t pid = 0;
        int status;
        while (pid != -1)
        {
            // Collects information about childs
            pid = waitpid(0, &status, 0);

            // If a child receives some signal, all processes created in the same line receive the same signal
            if (WIFSIGNALED(status))
            {
                killpg(group_leader, WTERMSIG(status));
            }
        }

        // After all background processes generated in the same command line finish, group leader finishes itself and become a zombie
        kill(getpid(), SIGTERM);
    }

    else
    {
        // The PID of the group leader (used to set group id) is registered in a vector of background groups id
        background_process_ids[*background_processes_amount] = group_leader;
        (*background_processes_amount)++;
    }

    return group_leader;
}

static void execute_process_foreground(char **foreground_process, pid_t group_id, __pid_t *background_processes_ids, int *background_processes_amount)
{
    char path[2000];

    // Definition of the path to executable that will be executed by the foreground process
    sprintf(path, "/bin/%s", foreground_process[0]);

    // Fork to create foreground process
    __pid_t pid = fork();

    if (pid == 0)
    {
        // If the foreground command is not htop or top, its group id is set to group id of the processes created in the same command line
        // If the foreground command is requested alone in line, its group id will be its PID
        // The verification of htop or top is made to ensure that these processes will execute in same group of shell, to avoid SIGTTY
        if (strcmp(foreground_process[0], "htop") && strcmp(foreground_process[0], "top"))
        {
            setpgid(0, group_id);
        }

        // Prevents the foreground process from SIGINT, SIGQUIT and SIGTSTP
        signal_prevent();

        // Execute the executable
        execv(path, foreground_process);

        // Print an error message if the exec was wrong
        printf(RED "Error on foreground execution: could not execute the command!\n" RESET);
        exit(1);
    }

    // Sleep a few milliseconds to ensure that group id of foregroun process was correctly set
    sleep(0.6);

    // If the group id is 0, the PID of the foreground process is registered in background ids vector
    // It doesn't make foreground process part of a background group. It just helps to kill foreground processes if die command is written or a signal is received
    if (group_id == 0)
    {
        background_processes_ids[*background_processes_amount] = pid;
        (*background_processes_amount)++;
    }

    // Shell still blocked while foreground process haven't finished yet
    int status;
    pid_t test = waitpid(pid, &status, 0);

    // After foreground execution, shell evaluates if the process was finished with a signal
    if (WIFSIGNALED(status))
    {
        // If true, the same signal is sent to all processes that share same group id with foreground process
        killpg(group_id, WTERMSIG(status));
    }

    // If foreground process was written alone in command line and it finishes, its PID (consequently its group id) is removed from background groups id vector
    if (group_id == 0)
    {
        background_processes_ids[(*background_processes_amount) - 1] = 0;
        (*background_processes_amount)--;
    }
}